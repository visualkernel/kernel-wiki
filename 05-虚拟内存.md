# 目标
为了便于实现多任务之下的内存管理，在物理内存之上抽象出了虚拟内存。程序访问虚拟内存单元而使用的地址称为虚拟地址（也称线性地址）。本章主要讲解80x86硬件环境中，虚拟内存是如何表示和管理的。

# 虚拟内存
虚拟内存的基本思想：每个程序拥有自己的虚拟地址空间，这个空间以页为单元划分成多个块。每个页有连续的地址范围，这些页被映射到物理内存。一个运行的程序并不需要所有的页都存放在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由内核负责将缺失的部分装入物理内存，并完成虚拟内存页与物理内存页的映射，再重新执行失败的指令。

# 分页
虚拟地址空间按固定大小划分为称为**页**的若干单元。在x86架构中，32位的处理器页默认大小为4KB，64位的处理器页默认大小为8KB。

因为虚拟地址空间划分是从0开始，且页大小固定，所有每个页在虚拟内存中位置都是固定的。以4KB页大小为单位，所以每个页的首地址依次为0, 4KB, 8KB, 16KB, ...。从0开始给每个页进行编号，该编号称为**页号**。如果知道了页号，就很容易计算出对应页的首地址了。

```
页的地址(页的首地址) = page_no * PAGE_SIZE
```

一般虚拟地址可以拆分为两部分：页号、页内偏移。通过页号可以找到具体的某个页，再加上页内偏移，就可以找到具体某个内存单元了。

```
内存地址 = page_no * PAGE_SIZE + offset
```

# 页表
页表是用于维护虚拟页到物理页的映射关系的集合。我们可以把页表看作是一个数组，数组中的每一个元素为页表项，而页号可以看作是页表项的索引。通过页号，可以找到对应的页表项。
```
页表项 = page_table[page_no]
```

页表项中保存着物理页号，这样就可以将页表项的页号和物理页号映射起来。
```
虚拟地址 = （页号， 页内偏移）        (物理页号，页内偏移) = 物理地址
             '--------->页表项------->'
```

页表项除了保存着物理页号，还包含了一些标志信息，比如页是否在内存中、是否为脏页、读写权限、特权权限、是否允许TLB缓存、交换标志等。

# 多级分页
当寻址地址位数变大时，可寻址的虚拟内存空间就会越大，在页大小不变的情况下，页表项就越多，那么需要的页表就越大。32位系统中，页大小为4KB，则需要映射2^20个页面。

为了避免把全部页表地址保存内存中，引入多级分页机制。假设将32位系统分为(PT1,PT2,offset),PT1和PT2和占10位，offset占12位。PT1为一级页表的页号。一级页表项中保存着二级页表的首地址，再通过PT2可以找到相应的二级页表的页表项。二级页表项中保存着物理页号，再加上偏移量就可以找到具体的内存单元了。

实际上大部分应用程序可能不需要多少物理内存，我们只需要将一级页表全部保存内存中，而二级页表可根据内存需求只保存一部分。这样就可以减少页表而节约内存空间了。

# Linux分页
在64位的系统中，Linux采用4级分页模式。