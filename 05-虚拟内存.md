# 目标
为了便于实现多任务之下的内存管理，在物理内存之上抽象出了虚拟内存。程序访问虚拟内存单元而使用的地址称为虚拟地址（也称线性地址）。本章主要讲解80x86硬件环境中，虚拟内存是如何表示和管理的。

# 虚拟内存
虚拟内存的基本思想：每个程序拥有自己的虚拟地址空间，这个空间以页为单元划分成多个块。每个页有连续的地址范围，这些页被映射到物理内存。一个运行的程序并不需要所有的页都存放在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由内核负责将缺失的部分装入物理内存，并完成虚拟内存页与物理内存页的映射，再重新执行失败的指令。

# 分页
虚拟地址空间按固定大小划分为称为**页**的若干单元。在x86架构中页大小默认为4KB。

因为虚拟地址空间划分是从0开始，且页大小固定，所有每个页在虚拟内存中位置都是固定的。以4KB页大小为单位，所以每个页的首地址依次为0, 4KB, 8KB, 16KB, ...。从0开始给每个页进行编号，该编号称为**页号**。如果知道了页号，就很容易计算出对应页的首地址了。

```
页的地址(页的首地址) = page_no * PAGE_SIZE
```

一般虚拟地址可以拆分为两部分：页号、页内偏移。通过页号可以找到具体的某个页，再加上页内偏移，就可以找到具体某个内存单元了。

```
内存地址 = page_no * PAGE_SIZE + offset
```

# 页表
页表是用于维护虚拟页到物理页的映射关系的集合。我们可以把页表看作是一个数组，数组中的每一个元素为页表项，而页号可以看作是页表项的索引。通过页号，可以找到对应的页表项。
```
页表项 = page_table[page_no]
```

页表项中保存着物理页号，这样就可以将页表项的页号和物理页号映射起来。
```
虚拟地址 = （页号， 页内偏移）        (物理页号，页内偏移) = 物理地址
             '--------->页表项------->'
```

页表项除了保存着物理页号，还包含了一些标志信息，比如页是否在内存中、是否为脏页、读写权限、特权权限、是否允许TLB缓存、交换标志等。

# 多级分页
当寻址地址位数变大时，可寻址的虚拟内存空间就会越大，在页大小不变的情况下，页表项就越多，那么需要的页表就越大。页大小为4KB，则需要映射2^20个页面。

为了避免把全部页表地址保存内存中，引入多级分页机制，即将页号拆分成多个部分。假设将32位系统分为(PT1,PT2,offset),PT1和PT2和占10位，offset占12位。PT1为一级页表的页号。一级页表项中保存着二级页表的首地址，再通过PT2可以找到相应的二级页表的页表项。二级页表项中保存着物理页号，再加上偏移量就可以找到具体的内存单元了。

在多级分页中，我们只需要将第一级的页表全部加载到内存中，而其它级别页表可根据进程内存需求动态来加载。拆分的级别越多，第一级的页表占用的内存就越少，如果使用二级分页，一级页表只占用了4K(`2^10*4`)大小，如果使用一级分页，则页表要占用4M(`2^20*4`)大小。因此多级页表可以大大减少页表占用的内存空间了。

# Linux分页
在x86_64位的系统中，Linux采用4级分页模式（将页号拆分成4个部分）。各级从高位到低位分别为：
* 页全局目录(Page Global Directory:PGD)
* 页上级目录(Page Upper Directory:PUD)
* 页中间目录(Page Middle Directory:PMD)
* 页表(Page Table:PTE)

每一级各占9 bit，页内偏移占12 bit。如下是各个部分在虚拟地址中的位置：
```
.----------------------------------------------.
|  PGD  |  PUD  |   PMD |  PTE  |     Offset   |
'----------------------------------------------'
                                |<-PAGE_SHIFT->|
                        |<-----PMD_SHIFT ----->|
                |<------PUD_SHIFT------------->|
        |<---------PGDIR_SHIFT---------------->|
```

分页模式与体系结构相关，x86_64的分页各级页项目占用的bit长度定义在`arch/x86/include/asm/pgtable_64_types.h`文件中。
```C
#define PAGETABLE_LEVELS	4 //页表级别
#define PGDIR_SHIFT	39
#define PUD_SHIFT	30
#define PMD_SHIFT	21
```
页的大小也与体系结构相关，x86_64的页大小定义在`arch/x86/include/asm/page_types.h`文件中。
```C
#define PAGE_SHIFT	12
#define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
```
每一级的目录项都是为了找到下一级目录表或页表的首地址。
* 页全局目录项:`pgd_t`
* 页上级目录项:`pud_t`
* 页中间目录项:`pmd_t`
* 页表项:`pte_t`
这些目录项数据结构定义在`arch/x86/include/asm/pgtable_types.h`文件中。
```C
//常量和类型别名定义在arch/x86/include/asm/pgtable_64_types.h中
typedef unsigned long   pteval_t;
typedef unsigned long   pmdval_t;
typedef unsigned long   pudval_t;
typedef unsigned long   pgdval_t;

typedef struct { pteval_t pte; } pte_t;
typedef struct { pgdval_t pgd; } pgd_t;
typedef struct { pudval_t pud; } pud_t;
typedef struct { pmdval_t pmd; } pmd_t;
```

在64位的系统中，`unsigned long`占有8个字节，一个4K大小的页可以存放512个页目录项。这也是为什么4级分页中每一级占用9bit的原因了。

按4级分页，我们可寻址的地址空间范围为`512*512*512*4K=16T`。实际上4级分页只使用虚拟地址低48bit用于寻址，到目前为16T是一个非常大的数字了，48bit的4级分页已经足够使用了。
